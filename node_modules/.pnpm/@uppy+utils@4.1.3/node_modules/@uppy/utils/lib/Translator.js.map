{"version":3,"sources":["Translator.js"],"names":["has","insertReplacement","source","rx","replacement","newParts","forEach","chunk","push","Symbol","split","raw","i","list","length","interpolate","phrase","options","dollarRegex","dollarBillsYall","interpolated","arg","Object","keys","replace","RegExp","Translator","constructor","locales","locale","strings","pluralize","n","Array","isArray","translate","key","translateArray","join","Error","string","hasPluralForms","smart_count","plural","prevLocale"],"mappings":"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","sourcesContent":["import has from './hasProperty.js'\n\nfunction insertReplacement (source, rx, replacement) {\n  const newParts = []\n  source.forEach((chunk) => {\n    // When the source contains multiple placeholders for interpolation,\n    // we should ignore chunks that are not strings, because those\n    // can be JSX objects and will be otherwise incorrectly turned into strings.\n    // Without this condition weâ€™d get this: [object Object] hello [object Object] my <button>\n    if (typeof chunk !== 'string') {\n      return newParts.push(chunk)\n    }\n\n    return rx[Symbol.split](chunk).forEach((raw, i, list) => {\n      if (raw !== '') {\n        newParts.push(raw)\n      }\n\n      // Interlace with the `replacement` value\n      if (i < list.length - 1) {\n        newParts.push(replacement)\n      }\n    })\n  })\n  return newParts\n}\n\n/**\n * Takes a string with placeholder variables like `%{smart_count} file selected`\n * and replaces it with values from options `{smart_count: 5}`\n *\n * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n *\n * @param {string} phrase that needs interpolation, with placeholders\n * @param {object} options with values that will be used to replace placeholders\n * @returns {any[]} interpolated\n */\nfunction interpolate (phrase, options) {\n  const dollarRegex = /\\$/g\n  const dollarBillsYall = '$$$$'\n  let interpolated = [phrase]\n\n  if (options == null) return interpolated\n\n  for (const arg of Object.keys(options)) {\n    if (arg !== '_') {\n      // Ensure replacement value is escaped to prevent special $-prefixed\n      // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n      // be escaped with \"$\" itself, and we need two in the resulting output.\n      let replacement = options[arg]\n      if (typeof replacement === 'string') {\n        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall)\n      }\n      // We create a new `RegExp` each time instead of using a more-efficient\n      // string replace so that the same argument can be replaced multiple times\n      // in the same phrase.\n      interpolated = insertReplacement(interpolated, new RegExp(`%\\\\{${arg}\\\\}`, 'g'), replacement)\n    }\n  }\n\n  return interpolated\n}\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nexport default class Translator {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  constructor (locales) {\n    this.locale = {\n      strings: {},\n      pluralize (n) {\n        if (n === 1) {\n          return 0\n        }\n        return 1\n      },\n    }\n\n    if (Array.isArray(locales)) {\n      locales.forEach(this.#apply, this)\n    } else {\n      this.#apply(locales)\n    }\n  }\n\n  #apply (locale) {\n    if (!locale?.strings) {\n      return\n    }\n\n    const prevLocale = this.locale\n    this.locale = { ...prevLocale, strings: { ...prevLocale.strings, ...locale.strings } }\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize\n  }\n\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */\n  translate (key, options) {\n    return this.translateArray(key, options).join('')\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */\n  translateArray (key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(`missing string: ${key}`)\n    }\n\n    const string = this.locale.strings[key]\n    const hasPluralForms = typeof string === 'object'\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count)\n        return interpolate(string[plural], options)\n      }\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}')\n    }\n\n    return interpolate(string, options)\n  }\n}\n"]}