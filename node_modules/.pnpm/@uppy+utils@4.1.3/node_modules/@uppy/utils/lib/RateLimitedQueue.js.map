{"version":3,"sources":["RateLimitedQueue.js"],"names":["createCancelError","Error","RateLimitedQueue","constructor","limit","resume","setTimeout","Math","ceil","i","floor","Infinity","run","fn","queueOptions","wrapPromiseFunction","args","queuedRequest","outerPromise","Promise","resolve","reject","cancelError","innerPromise","err","then","result","done","abort","clearTimeout","pause","duration","rateLimit","Number","isFinite","isPaused","cancelActive","queueMicrotask","length","next","shift","handler","options","priority","index","findIndex","other","push","splice","indexOf","internalRateLimitedQueue","Symbol"],"mappings":"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","sourcesContent":["function createCancelError () {\n  return new Error('Cancelled')\n}\n\nexport class RateLimitedQueue {\n  #activeRequests = 0\n\n  #queuedHandlers = []\n\n  #paused = false\n\n  #pauseTimer\n\n  #downLimit = 1\n\n  #upperLimit\n\n  #rateLimitingTimer\n\n  constructor (limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity\n    } else {\n      this.limit = limit\n    }\n  }\n\n  #call (fn) {\n    this.#activeRequests += 1\n\n    let done = false\n\n    let cancelActive\n    try {\n      cancelActive = fn()\n    } catch (err) {\n      this.#activeRequests -= 1\n      throw err\n    }\n\n    return {\n      abort: () => {\n        if (done) return\n        done = true\n        this.#activeRequests -= 1\n        cancelActive()\n        this.#queueNext()\n      },\n\n      done: () => {\n        if (done) return\n        done = true\n        this.#activeRequests -= 1\n        this.#queueNext()\n      },\n    }\n  }\n\n  #queueNext () {\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    queueMicrotask(() => this.#next())\n  }\n\n  #next () {\n    if (this.#paused || this.#activeRequests >= this.limit) {\n      return\n    }\n    if (this.#queuedHandlers.length === 0) {\n      return\n    }\n\n    // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n    const next = this.#queuedHandlers.shift()\n    const handler = this.#call(next.fn)\n    next.abort = handler.abort\n    next.done = handler.done\n  }\n\n  #queue (fn, options = {}) {\n    const handler = {\n      fn,\n      priority: options.priority || 0,\n      abort: () => {\n        this.#dequeue(handler)\n      },\n      done: () => {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug')\n      },\n    }\n\n    const index = this.#queuedHandlers.findIndex((other) => {\n      return handler.priority > other.priority\n    })\n    if (index === -1) {\n      this.#queuedHandlers.push(handler)\n    } else {\n      this.#queuedHandlers.splice(index, 0, handler)\n    }\n    return handler\n  }\n\n  #dequeue (handler) {\n    const index = this.#queuedHandlers.indexOf(handler)\n    if (index !== -1) {\n      this.#queuedHandlers.splice(index, 1)\n    }\n  }\n\n  run (fn, queueOptions) {\n    if (!this.#paused && this.#activeRequests < this.limit) {\n      return this.#call(fn)\n    }\n    return this.#queue(fn, queueOptions)\n  }\n\n  wrapPromiseFunction (fn, queueOptions) {\n    return (...args) => {\n      let queuedRequest\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = this.run(() => {\n          let cancelError\n          let innerPromise\n          try {\n            innerPromise = Promise.resolve(fn(...args))\n          } catch (err) {\n            innerPromise = Promise.reject(err)\n          }\n\n          innerPromise.then((result) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              resolve(result)\n            }\n          }, (err) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              reject(err)\n            }\n          })\n\n          return () => {\n            cancelError = createCancelError()\n          }\n        }, queueOptions)\n      })\n\n      outerPromise.abort = () => {\n        queuedRequest.abort()\n      }\n\n      return outerPromise\n    }\n  }\n\n  resume () {\n    this.#paused = false\n    clearTimeout(this.#pauseTimer)\n    for (let i = 0; i < this.limit; i++) {\n      this.#queueNext()\n    }\n  }\n\n  #resume = () => this.resume()\n\n  /**\n   * Freezes the queue for a while or indefinitely.\n   *\n   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n   *                                    If omitted, the queue won't resume automatically.\n   */\n  pause (duration = null) {\n    this.#paused = true\n    clearTimeout(this.#pauseTimer)\n    if (duration != null) {\n      this.#pauseTimer = setTimeout(this.#resume, duration)\n    }\n  }\n\n  /**\n   * Pauses the queue for a duration, and lower the limit of concurrent requests\n   * when the queue resumes. When the queue resumes, it tries to progressively\n   * increase the limit in `this.#increaseLimit` until another call is made to\n   * `this.rateLimit`.\n   * Call this function when using the RateLimitedQueue for network requests and\n   * the remote server responds with 429 HTTP code.\n   *\n   * @param {number} duration in milliseconds.\n   */\n  rateLimit (duration) {\n    clearTimeout(this.#rateLimitingTimer)\n    this.pause(duration)\n    if (this.limit > 1 && Number.isFinite(this.limit)) {\n      this.#upperLimit = this.limit - 1\n      this.limit = this.#downLimit\n      this.#rateLimitingTimer = setTimeout(this.#increaseLimit, duration)\n    }\n  }\n\n  #increaseLimit = () => {\n    if (this.#paused) {\n      this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 0)\n      return\n    }\n    this.#downLimit = this.limit\n    this.limit = Math.ceil((this.#upperLimit + this.#downLimit) / 2)\n    for (let i = this.#downLimit; i <= this.limit; i++) {\n      this.#queueNext()\n    }\n    if (this.#upperLimit - this.#downLimit > 3) {\n      this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 2000)\n    } else {\n      this.#downLimit = Math.floor(this.#downLimit / 2)\n    }\n  }\n\n  get isPaused () { return this.#paused }\n}\n\nexport const internalRateLimitedQueue = Symbol('__queue')\n"]}